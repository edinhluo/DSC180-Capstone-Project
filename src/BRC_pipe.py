from seirsplus.models import *
from seirsplus.networks import *
from seirsplus.sim_loops import *
from seirsplus.utilities import *
import networkx 
import pandas as pd
import numpy as np
import os
import extendedNetC as ec
from imblearn.ensemble import BalancedRandomForestClassifier
import pool_func as pfunc
from sklearn.utils.class_weight import compute_class_weight


def find_infected(A,y):
    infected_vec = np.zeros((1,A.shape[1]))
    for x in range(A.shape[0]):
        if y[x] == 0:
            infected_vec += A[x]
    return (infected_vec == 0) * 1


#rewrite infec func
#generate infec matrix based on network data
def generate_infected(posidx,G):
    """
    generate infec matrix based on network data
    
    input: 
        posidx: positive ppl index generated by the extendedNet func
        G: disease network model (model.G from extendedNet func)
        
    output:
        
    """

    ### Create the "Infected" Binary X Vector
    X = np.zeros((1, len(G)))
    
    ### assign pos ppl based on network result
    for positive in posidx:
        X[0][positive] = 1

    return X


def BRFpipe(data,**kwargs):
	""" 
	balanced random forest piepeline

	return summary of predictive probabilities 
	generated by randomforest classifier


	"""

	df = pd.read_csv(data)
	os.makedirs("outdir", exist_ok = True)

	for index,row in df.iterrows():
		N = row['N']
		days = row['days']

	base,age,households,model,pos = ec.extendedNet(N,days)
	#creat a new df
	dfs = ec.DicCollection(model.G,age,households)

	#get number of times each individual appear in a positive pool
	#pool size = default size 32
	numtests = N//32

	A = pfunc.generate_pool(numtests, N)
	X = generate_infected(pos,model.G)
	Y = pfunc.eval_matrix(A, X)
	infec_count = pfunc.find_infected_counted(A,Y).tolist()

	#add infec count into table
	dfp = dfs.assign(count = infec_count)


	#put positive state back to tabel
	dfp2 = dfp.assign(positive = [0]*len(model.G))
	dfp2.iloc[pos,dfp2.columns.get_loc('positive')] = 1

	transDF = ec.transformAge(dfp2)

	#create X and y, convert to matrix format
	X3 = transDF.iloc[:,:-1].to_numpy() #exclude result
	y3 = transDF['positive'].to_numpy()

	#use 1/2 for training
	X_train3 = X3[:N//2]
	y_train3 = y3[:N//2]


	X_test3 = X3[N//2:]
	y_test3 = y3[N//2:]

	#compute class weight for unbalanced dataset
	classWeight3 = compute_class_weight('balanced',classes = [0,1],y= y_train3)
	classWeight3

	BRFC3 = BalancedRandomForestClassifier(n_estimators=100, random_state=2,
                                     min_samples_leaf =3,class_weight = {0:classWeight3[0],1:classWeight3[1]},
                                     sampling_strategy = 'not majority')

	BRFC3.fit(X_train3, y_train3)
	y_predbrf3 = list(BRFC3.predict(X_test3))

	yp = pd.DataFrame(y_predbrf3)
	
	yp.to_csv('report/BRCpredict.csv', index = False)

	return yp






